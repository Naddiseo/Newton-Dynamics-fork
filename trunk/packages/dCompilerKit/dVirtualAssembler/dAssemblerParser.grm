/* Copyright (c) <2009> <Newton Game Dynamics>
* 
* This software is provided 'as-is', without any express or implied
* warranty. In no event will the authors be held liable for any damages
* arising from the use of this software.
* 
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely
*/

%{
#include <dAssemblerCompiler.h>
#include "dAssemblerLexical.h"

//
// Newton virtual machine assembler grammar
// based loosely on a subset and a hybrid between the MIPS R3000 and the Intel 386 instructions set 
//
%}


%union 
{
	class dUserVariable
	{
		public:
		dUserVariable () 
			:m_token (dToken (0)), m_semanticValue(0), m_data("")
		{
		}
		
		
		dUserVariable (dToken token, const char* const text)
			:m_token(token), m_semanticValue(0), m_data (text) 
		{
		}
		dToken m_token;
		int m_semanticValue;
		string m_data;
	};
}


	
%token IMPORT LITERAL PRIVATE

%token BEGIN END

%token INT

%token INTEGER 

%token REGISTER


%token MOVE 
%token LOADB LOADW LOADD 
%token STOREB STOREW STORED
%token SLL SRL
%token AND OR XOR NOT
%token ADDI ADD SUB MUL DIV ABS NEG
%token BEQ BNE BLT BLE BGT BGET
%token CALL CALLR RET SYSCALL JUMP JUMPR
%token ENTER EXIT PUSH POP
%token JUMPLABEL		  



%start module


%%
module		: segmentList
			|
			;
				
				
segmentList	: segment 
			| segmentList segment 
			;
			
			
segment		: import
			| dataDeclaration	
			| functionDeclaration
			;
			
			
import		: IMPORT '<' fileName '>'
			; 			
			
fileName	: literal
			| fileName '.' literal
			;
			
dataDeclaration	: dataType literal							{((dAssemblerCompiler*)this)->EmitUnInitilizedDataDeclaration ($1, $2);}		
				| dataType literal '=' constantExpression	{((dAssemblerCompiler*)this)->EmitInitilizedDataDeclaration ($1, $2, $4);}
				;
				
				   
dataType		: INT {$$ = ((dAssemblerCompiler*)this)->EmitDataType ($1);}
				;				

literal			: LITERAL {$$ = ((dAssemblerCompiler*)this)->EmitSymbol ($1);}
				;	


visibility	: PRIVATE
			|
			;

functionDeclaration	: beginFunction instructionList END 
						{
							dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
							me->EmitEndFunction ();
						}
					;

beginFunction : BEGIN literal visibility 
				{ 
					dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
					me->EmitBeginFunction ($2, $3);
				}
			  ;


instructionList	: instruction
				| instructionList instruction
				;

instruction	: instructionType0
			| instructionType1
			| instructionType2
			;
			
opcodeType0 : JUMPR {$$ = $1; $$.m_semanticValue = dVirtualMachine::jumpr;}
			| RET {$$ = $1; $$.m_semanticValue = dVirtualMachine::ret;}
			;
				 
opcodeType1 : CALL {$$ = $1; $$.m_semanticValue = dVirtualMachine::call;}
			;

pushPopOpcode : PUSH {$$ = $1; $$.m_semanticValue = dVirtualMachine::push;}
			  | POP {$$ = $1; $$.m_semanticValue = dVirtualMachine::pop;}
			  ;
			  
opcodeAddi : ADDI {$$ = $1; $$.m_semanticValue = dVirtualMachine::addi;}			  
		   ;

opcodeType2 : BEQ {$$ = $1; $$.m_semanticValue = dVirtualMachine::beq;}
			| BNE {$$ = $1; $$.m_semanticValue = dVirtualMachine::bne;}
			| BLT {$$ = $1; $$.m_semanticValue = dVirtualMachine::blt;}
			| BLE {$$ = $1; $$.m_semanticValue = dVirtualMachine::ble;}
			| BGT {$$ = $1; $$.m_semanticValue = dVirtualMachine::bgt;}
			| BGET {$$ = $1; $$.m_semanticValue = dVirtualMachine::bget;}
			;
			 
			
/*				 
opcode	:MOVE {$$ = $1; $$.m_semanticValue = dVirtualMachine::mov;}
		|ADD {$$ = $1; $$.m_semanticValue = dVirtualMachine::add;}
		|SUB {$$ = $1; $$.m_semanticValue = dVirtualMachine::sub;}
		|MUL {$$ = $1; $$.m_semanticValue = dVirtualMachine::mul;}
		|DIV {$$ = $1; $$.m_semanticValue = dVirtualMachine::div;}
		|ABS {$$ = $1; $$.m_semanticValue = dVirtualMachine::abs;}
		|NEG {$$ = $1; $$.m_semanticValue = dVirtualMachine::neg;}
		|AND {$$ = $1; $$.m_semanticValue = dVirtualMachine::and;}
		|OR  {$$ = $1; $$.m_semanticValue = dVirtualMachine::or;}
		|XOR {$$ = $1; $$.m_semanticValue = dVirtualMachine::xor;}
		|NOT {$$ = $1; $$.m_semanticValue = dVirtualMachine::not;}
		|SLL {$$ = $1; $$.m_semanticValue = dVirtualMachine::sll;}
		|SRL {$$ = $1; $$.m_semanticValue = dVirtualMachine::srl;}
		|LOADB {$$ = $1; $$.m_semanticValue = dVirtualMachine::loadb;}
		|LOADW {$$ = $1; $$.m_semanticValue = dVirtualMachine::loadw;}
		|LOADD {$$ = $1; $$.m_semanticValue = dVirtualMachine::loadd;}
		|STOREB {$$ = $1; $$.m_semanticValue = dVirtualMachine::storeb;}
		|STOREW {$$ = $1; $$.m_semanticValue = dVirtualMachine::storew;}
		|STORED {$$ = $1; $$.m_semanticValue = dVirtualMachine::stored;}
		|CALLR {$$ = $1; $$.m_semanticValue = dVirtualMachine::callr;}
		
		|SYSCALL {$$ = $1; $$.m_semanticValue = dVirtualMachine::syscall;}
		|JUMP {$$ = $1; $$.m_semanticValue = dVirtualMachine::jump;}
		|ENTER {$$ = $1; $$.m_semanticValue = dVirtualMachine::enter;}
		|EXIT {$$ = $1; $$.m_semanticValue = dVirtualMachine::exit;}
*/
		
/*
instruction	: load
			| store
			| constAdd
			| arithmetic
			| conditional
			| callJumpRet
			| stack
			| jumpLabel
			;
			
		
load : loadOpcode register ',' literal
	 ;			
	 
store : storeOpcode register ',' literal
	  ;			
 

					
					
					
jumpLabel : JUMPLABEL
			{ 
				dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
//				me->EmitJumpDestLabel ($1);
			}
		  ;			
					
constAdd : ADDI register ',' constantExpression 
			{ 
				dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
				dUserVariable register0 (REGISTER, "r0");
				me->EmitInstrutionType2 ($2, register0, $4);
			}
		 | ADDI register ',' literal 
		 | ADDI register ',' register ',' literal 
		 ;

				  
				   
callJumpRet : 
			| CALLR register
			| CALLR register ',' register
			| SYSCALL register ',' register ',' literal
			| JUMP register
			| JUMPR literal
			;

conditional : conditionalOpcode register ',' register ',' literal
				{
					dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
//					me->EmitCompareAndJumpLocalLabel ($1, $2, $4, $6);
				}
			| conditionalOpcode register ',' register ',' constantExpression
				{
					dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
//					me->EmitCompareAndJumpConstOffset ($1, $2, $4, $6);
				}
			;
				   
arithmetic : arithmeticOpcode register ',' register
				{
					dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
//					me->EmitArithmeticInstrution ($1, $2, $4);
				}
			;
			
stack : ENTER register ',' register ',' constantExpression
	  | EXIT register ',' register
	  | pushPop register
	  | pushPop register, register
	  | pushPop '{' registerMask '}'
		{
			dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
			char text[64];
			sprintf (text, "r%d", me->m_virtualMachine->GetRegisterCount() - 1);
			dUserVariable stackRegister (REGISTER, text);
			stackRegister.m_semanticValue = me->m_virtualMachine->GetRegisterCount() - 1;
			me->EmitInstrutionType1 ($1, stackRegister, $3);
		}
	  
	  | pushPop register ',' '{' registerMask '}'
			{
				dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
				me->EmitInstrutionType1 ($1, $2, $5);
			}
	  ;
*/	  
			
constantExpression : INTEGER {$$ = ((dAssemblerCompiler*)this)->EmitIntegerConst ($1);}
				   ;	

register : REGISTER
			{
				dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
				$$ = me->TypeCheckRegister ($1);
			}
		 ;
		 
registerMask : register	 {$$ = $1; $$.m_semanticValue = 1 << $1.m_semanticValue;}  
			 | registerMask ',' register {$$ = $1; $$.m_semanticValue = $1.m_semanticValue | (1 << $3.m_semanticValue);}
			 ;	


instructionType0 : opcodeType0 
				 {
					dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
					char text[64];
					sprintf (text, "r%d", me->m_virtualMachine->GetRegisterCount() - 1);
					dUserVariable stackRegister (REGISTER, text);
					stackRegister.m_semanticValue = me->m_virtualMachine->GetRegisterCount() - 1;
					me->EmitInstrutionType0 ($1, stackRegister);
				}
				
				| opcodeType0 register
				{
					dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
					me->EmitInstrutionType0 ($1, $2);
				}
				;
				


instructionType1 : pushPopOpcode '{' registerMask '}'
					{
						dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
						char text[64];
						sprintf (text, "r%d", me->m_virtualMachine->GetRegisterCount() - 1);
						dUserVariable stackRegister (REGISTER, text);
						stackRegister.m_semanticValue = me->m_virtualMachine->GetRegisterCount() - 1;
						me->EmitInstrutionType1 ($1, stackRegister, $3);
					}
				| pushPopOpcode register ',' '{' registerMask '}'	
					{
						dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
						me->EmitInstrutionType1 ($1, $2, $5);
					}
				| pushPopOpcode register
				| pushPopOpcode register, register
				
				| opcodeType1 literal
					{
						dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
						dUserVariable register0 (REGISTER, "r0");
						me->EmitInstrutionType1_label ($1, register0, $2);
					}
				| opcodeType1 register ',' literal
					{
						dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
						me->EmitInstrutionType1_label ($1, $2, $4);
					}
				;

				
instructionType2 : opcodeAddi register ',' constantExpression 
					{ 
						dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
						dUserVariable register0 (REGISTER, "r0");
						me->EmitInstrutionType2 ($1, $2, register0, $4);
					}
				 | opcodeAddi register ',' register ',' constantExpression 			
					{ 
						dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
						me->EmitInstrutionType2 ($1, $2, $4, $6);
					}
				 | opcodeAddi register ',' literal 
				 | opcodeAddi register ',' register ',' literal 					
				 ;				

%%

