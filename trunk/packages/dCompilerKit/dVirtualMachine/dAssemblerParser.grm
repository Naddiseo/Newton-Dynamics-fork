/* Copyright (c) <2009> <Newton Game Dynamics>
* 
* This software is provided 'as-is', without any express or implied
* warranty. In no event will the authors be held liable for any damages
* arising from the use of this software.
* 
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely
*/

%{
#include <dVirtualMachine.h>
#include "dAssemblerLexical.h"
#include "dAssemblerCompiler.h"
//
// Newton virtual machine assembler grammar
// based loosely on a subset and a hybrid between the MIPS R3000 and the Intel 386 instructions set 
//
%}


%union 
{
	class dUserVariable
	{
		public:
		dUserVariable () 
			:m_token (dToken (0)), m_semanticValue(0), m_data("")
		{
		}
		
		
		dUserVariable (dToken token, const char* const text)
			:m_token(token), m_semanticValue(0), m_data (text) 
		{
		}
		dToken m_token;
		int m_semanticValue;
		string m_data;
	};
}


	
%token IMPORT LITERAL PRIVATE

%token BEGIN END

%token INT

%token INTEGER 

%token REGISTER


%token MOVE 
%token LOADB LOADW LOADD 
%token STOREB STOREW STORED
%token SLL SRL
%token AND OR XOR NOT
%token ADDI ADD SUB MUL DIV ABS NEG
%token BEQ BNE BLT BLE BGT BGET
%token CALL CALLR RET SYSCALL JUMP JUMPR
%token ENTER EXIT PUSH POP
%token JUMPLABEL		  



%start module


%%
module		: segmentList
			|
			;
				
				
segmentList	: segment 
			| segmentList segment 
			;
			
			
segment		: import
			| dataDeclaration	
			| functionDeclaration
			;
			
			
import		: IMPORT '<' fileName '>'
			; 			
			
fileName	: literal
			| fileName '.' literal
			;
			
dataDeclaration	: dataType literal							{((dAssemblerCompiler*)this)->EmitUnInitilizedDataDeclaration ($1, $2);}		
				| dataType literal '=' constantExpression	{((dAssemblerCompiler*)this)->EmitInitilizedDataDeclaration ($1, $2, $4);}
				;
				
				   
dataType		: INT {$$ = ((dAssemblerCompiler*)this)->EmitDataType ($1);}
				;				

literal			: LITERAL {$$ = ((dAssemblerCompiler*)this)->EmitSymbol ($1);}
				;	


instructionList	: instruction
				| instructionList instruction
				;

instruction	: load
			| store
			| constAdd
			| arithmetic
			| conditional
			| callJumpRet
			| stack
			| jumpLabel
			;
			
		
load : loadOpcode register ',' literal
	 ;			
	 
store : storeOpcode register ',' literal
	  ;			
 
				 
loadOpcode : LOADB
		   | LOADW
		   | LOADD		   
		   ;
		   
storeOpcode : STOREB
			| STOREW
			| STORED			
		    ;
				 
visibility	: PRIVATE
			|
			;

pushPop	: PUSH {$$ = $1;  $$.m_semanticValue = dVirtualMachine::push;}
		| POP {$$ = $1;  $$.m_semanticValue = dVirtualMachine::pop;}
		;

arithmeticOpcode : ADD {$$ = $1;  $$.m_semanticValue = dVirtualMachine::add;}
				 | SUB {$$ = $1;  $$.m_semanticValue = dVirtualMachine::sub;}	
				 | MUL {$$ = $1;  $$.m_semanticValue = dVirtualMachine::mul;}
				 | DIV {$$ = $1;  $$.m_semanticValue = dVirtualMachine::div;}
				 | ABS {$$ = $1;  $$.m_semanticValue = dVirtualMachine::abs;}
				 | NEG {$$ = $1;  $$.m_semanticValue = dVirtualMachine::neg;}
				 | AND {$$ = $1;  $$.m_semanticValue = dVirtualMachine::and;}
				 | OR	{$$ = $1;  $$.m_semanticValue = dVirtualMachine::or;}
				 | XOR {$$ = $1;  $$.m_semanticValue = dVirtualMachine::xor;}
				 | NOT {$$ = $1;  $$.m_semanticValue = dVirtualMachine::not;}				 
				 | SLL {$$ = $1;  $$.m_semanticValue = dVirtualMachine::sll;}
				 | SRL {$$ = $1;  $$.m_semanticValue = dVirtualMachine::srl;}
				 | MOVE {$$ = $1;  $$.m_semanticValue = dVirtualMachine::mov;}
				 ;

conditionalOpcode : BEQ {$$ = $1;  $$.m_semanticValue = dVirtualMachine::beq;}
				  | BNE {$$ = $1;  $$.m_semanticValue = dVirtualMachine::bne;}
				  | BLT {$$ = $1;  $$.m_semanticValue = dVirtualMachine::blt;}
				  | BLE {$$ = $1;  $$.m_semanticValue = dVirtualMachine::ble;}
				  | BGT {$$ = $1;  $$.m_semanticValue = dVirtualMachine::bgt;}
				  | BGET {$$ = $1; $$.m_semanticValue = dVirtualMachine::bget;}
				  ;

beginFunction : BEGIN literal visibility 
				{ 
					dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
					me->EmitBeginFunction ($2, $3);
				}
			  ;

registerMask : register	 {$$ = $1; $$.m_semanticValue = 1 << $1.m_semanticValue;}  
			 | registerMask ',' register {$$ = $1; $$.m_semanticValue = $1.m_semanticValue | (1 << $3.m_semanticValue);}
			 ;	
					
					
functionDeclaration	: beginFunction instructionList END 
						{
							dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
							me->EmitEndFunction ();
						}
					;
					
jumpLabel : JUMPLABEL
			{ 
				dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
//				me->EmitJumpDestLabel ($1);
			}
		  ;			
					
constAdd : ADDI register ',' constantExpression 
			{ 
				dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
				dUserVariable register0 (REGISTER, "r0");
				me->EmitInstrutionType2 ($2, register0, $4);
			}
		 | ADDI register ',' register ',' constantExpression 			
			{ 
				dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
//				me->EmitADDIConstantExpresion ($2, $4, $6);
			}
		 | ADDI register ',' literal 
		 | ADDI register ',' register ',' literal 
		 ;

register : REGISTER
			{
				dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
				$$ = me->TypeCheckRegister ($1);
			}
		 ;
				  
constantExpression : INTEGER {$$ = ((dAssemblerCompiler*)this)->EmitIntegerConst ($1);}
				   ;	
				   
callJumpRet : CALL literal
				{
					dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
					dUserVariable register0 (REGISTER, "r0");
//					me->EmitCALL (register0, $2);
				}
			| CALL register ',' literal
				{
					dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
//					me->EmitCALL ($2, $4);
				}
			| CALLR register
			| CALLR register ',' register
			| RET 
				{
					dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
					dUserVariable register0 (REGISTER, "r0");
//					me->EmitRET (register0);
				}
			| RET register
				{
					dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
//					me->EmitRET ($2);
				}
			| SYSCALL register ',' register ',' literal
			| JUMP register
			| JUMPR literal
			;

conditional : conditionalOpcode register ',' register ',' literal
				{
					dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
//					me->EmitCompareAndJumpLocalLabel ($1, $2, $4, $6);
				}
			| conditionalOpcode register ',' register ',' constantExpression
				{
					dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
//					me->EmitCompareAndJumpConstOffset ($1, $2, $4, $6);
				}
			;
				   
arithmetic : arithmeticOpcode register ',' register
				{
					dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
//					me->EmitArithmeticInstrution ($1, $2, $4);
				}
			;
			
stack : ENTER register ',' register ',' constantExpression
	  | EXIT register ',' register
	  | pushPop register
	  | pushPop register, register
	  | pushPop '{' registerMask '}'
		{
			dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
			char text[64];
			sprintf (text, "r%d", me->m_virtualMachine->GetRegisterCount() - 1);
			dUserVariable stackRegister (REGISTER, text);
			stackRegister.m_semanticValue = me->m_virtualMachine->GetRegisterCount() - 1;
			me->EmitInstrutionType1 ($1, stackRegister, $3);
		}
	  
	  | pushPop register ',' '{' registerMask '}'
			{
				dAssemblerCompiler* const me = (dAssemblerCompiler*) this;
				me->EmitInstrutionType1 ($1, $2, $5);
			}
	  ;
	  
			

%%

