<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>HACD: C:/Users/kmammou/Dev/HACD/src/HACD_Lib/src/hacdGraph.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">HACD&#160;<span id="projectnumber">0.0.1</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">C:/Users/kmammou/Dev/HACD/src/HACD_Lib/src/hacdGraph.cpp</div>  </div>
</div>
<div class="contents">
<a href="hacd_graph_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Copyright (c) 2011 Khaled Mamou (kmamou at gmail dot com)</span>
<a name="l00002"></a>00002 <span class="comment"> All rights reserved.</span>
<a name="l00003"></a>00003 <span class="comment"> </span>
<a name="l00004"></a>00004 <span class="comment"> </span>
<a name="l00005"></a>00005 <span class="comment"> Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment"> </span>
<a name="l00007"></a>00007 <span class="comment"> 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00008"></a>00008 <span class="comment"> </span>
<a name="l00009"></a>00009 <span class="comment"> 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00010"></a>00010 <span class="comment"> </span>
<a name="l00011"></a>00011 <span class="comment"> 3. The names of the contributors may not be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00012"></a>00012 <span class="comment"> </span>
<a name="l00013"></a>00013 <span class="comment"> THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00014"></a>00014 <span class="comment"> */</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;<a class="code" href="hacd_graph_8h.html">hacdGraph.h</a>&gt;</span>
<a name="l00016"></a>00016 <span class="keyword">namespace </span>HACD
<a name="l00017"></a>00017 {    
<a name="l00018"></a>00018     
<a name="l00019"></a><a class="code" href="class_h_a_c_d_1_1_graph_edge.html#ae40ad49cf083c15f677f8bd4e6dab21f">00019</a>     <a class="code" href="class_h_a_c_d_1_1_graph_edge.html#ae40ad49cf083c15f677f8bd4e6dab21f">GraphEdge::GraphEdge</a>()
<a name="l00020"></a>00020     {
<a name="l00021"></a>00021         m_convexHull = 0;
<a name="l00022"></a>00022         m_v1 = -1;
<a name="l00023"></a>00023         m_v2 = -1;
<a name="l00024"></a>00024                 m_name = -1;
<a name="l00025"></a>00025         m_error = 0.0;
<a name="l00026"></a>00026         m_surf = 0.0;
<a name="l00027"></a>00027         m_perimeter = 0.0;
<a name="l00028"></a>00028         m_concavity = 0.0;
<a name="l00029"></a>00029         m_deleted = <span class="keyword">false</span>;
<a name="l00030"></a>00030         }
<a name="l00031"></a>00031    
<a name="l00032"></a><a class="code" href="class_h_a_c_d_1_1_graph_vertex.html#a95abc3e1fbc8faf085a4ccdc7c341a4d">00032</a>     <a class="code" href="class_h_a_c_d_1_1_graph_vertex.html#a95abc3e1fbc8faf085a4ccdc7c341a4d">GraphVertex::GraphVertex</a>()
<a name="l00033"></a>00033     {
<a name="l00034"></a>00034         m_convexHull = 0;
<a name="l00035"></a>00035                 m_name = -1;
<a name="l00036"></a>00036         m_cc = -1;        
<a name="l00037"></a>00037         m_error = 0.0;
<a name="l00038"></a>00038         m_surf = 0.0;
<a name="l00039"></a>00039         m_perimeter = 0.0;
<a name="l00040"></a>00040         m_concavity = 0.0;
<a name="l00041"></a>00041         m_deleted = <span class="keyword">false</span>;
<a name="l00042"></a>00042     }
<a name="l00043"></a>00043     
<a name="l00044"></a><a class="code" href="class_h_a_c_d_1_1_graph_vertex.html#a8b2cf4d873c2b13c143cf72264b7e39d">00044</a>     <span class="keywordtype">bool</span> <a class="code" href="class_h_a_c_d_1_1_graph_vertex.html#a8b2cf4d873c2b13c143cf72264b7e39d">GraphVertex::DeleteEdge</a>(<span class="keywordtype">long</span> name)
<a name="l00045"></a>00045     {
<a name="l00046"></a>00046         std::set&lt;long&gt;::iterator it = m_edges.find(name);
<a name="l00047"></a>00047         <span class="keywordflow">if</span> (it != m_edges.end() )
<a name="l00048"></a>00048                 {
<a name="l00049"></a>00049                         m_edges.erase(it);
<a name="l00050"></a>00050                         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00051"></a>00051                 }
<a name="l00052"></a>00052         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00053"></a>00053     }
<a name="l00054"></a>00054 
<a name="l00055"></a><a class="code" href="class_h_a_c_d_1_1_graph.html#a11783ac20ad63cc377bae21979c91ab3">00055</a>     <a class="code" href="class_h_a_c_d_1_1_graph.html#a11783ac20ad63cc377bae21979c91ab3">Graph::Graph</a>()
<a name="l00056"></a>00056     {
<a name="l00057"></a>00057         m_nV = 0;
<a name="l00058"></a>00058         m_nE = 0;
<a name="l00059"></a>00059         m_nCCs = 0;
<a name="l00060"></a>00060     }
<a name="l00061"></a>00061     
<a name="l00062"></a><a class="code" href="class_h_a_c_d_1_1_graph.html#ab05568c89ba9d0cbe52dfa814d5871f8">00062</a>     <a class="code" href="class_h_a_c_d_1_1_graph.html#ab05568c89ba9d0cbe52dfa814d5871f8">Graph::~Graph</a>()
<a name="l00063"></a>00063     {
<a name="l00064"></a>00064     }
<a name="l00065"></a>00065     
<a name="l00066"></a><a class="code" href="class_h_a_c_d_1_1_graph.html#aadc33ab16180e196fd63c6f9f725989c">00066</a>         <span class="keywordtype">void</span> <a class="code" href="class_h_a_c_d_1_1_graph.html#aadc33ab16180e196fd63c6f9f725989c">Graph::Allocate</a>(<span class="keywordtype">size_t</span> nV, <span class="keywordtype">size_t</span> nE)
<a name="l00067"></a>00067         { 
<a name="l00068"></a>00068                 m_nV = nV;
<a name="l00069"></a>00069                 m_edges.reserve(nE);
<a name="l00070"></a>00070                 m_vertices.resize(nV);
<a name="l00071"></a>00071                 <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; nV; i++)
<a name="l00072"></a>00072                 {
<a name="l00073"></a>00073                         m_vertices[i].m_name = <span class="keyword">static_cast&lt;</span><span class="keywordtype">long</span><span class="keyword">&gt;</span>(i);
<a name="l00074"></a>00074                 }
<a name="l00075"></a>00075         }
<a name="l00076"></a>00076 
<a name="l00077"></a><a class="code" href="class_h_a_c_d_1_1_graph.html#ac387d4c1647fdfe958649773a6766c42">00077</a>     <span class="keywordtype">long</span> <a class="code" href="class_h_a_c_d_1_1_graph.html#ac387d4c1647fdfe958649773a6766c42">Graph::AddVertex</a>()
<a name="l00078"></a>00078     {
<a name="l00079"></a>00079                 <span class="keywordtype">size_t</span> name = m_vertices.size();
<a name="l00080"></a>00080                 m_vertices.resize(name+1);
<a name="l00081"></a>00081         m_vertices[name].m_name = name;
<a name="l00082"></a>00082         m_nV++;
<a name="l00083"></a>00083         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">long</span><span class="keyword">&gt;</span>(name);
<a name="l00084"></a>00084     }
<a name="l00085"></a>00085     
<a name="l00086"></a><a class="code" href="class_h_a_c_d_1_1_graph.html#a0d079952cce618a81fb46c13910d0109">00086</a>     <span class="keywordtype">long</span> <a class="code" href="class_h_a_c_d_1_1_graph.html#a0d079952cce618a81fb46c13910d0109">Graph::AddEdge</a>(<span class="keywordtype">long</span> v1, <span class="keywordtype">long</span> v2)
<a name="l00087"></a>00087     {
<a name="l00088"></a>00088                 <span class="keywordtype">size_t</span> name = m_edges.size();
<a name="l00089"></a>00089                 m_edges.push_back(<a class="code" href="class_h_a_c_d_1_1_graph_edge.html">GraphEdge</a>());
<a name="l00090"></a>00090         m_edges[name].m_name = name;
<a name="l00091"></a>00091         m_edges[name].m_v1 = v1;
<a name="l00092"></a>00092         m_edges[name].m_v2 = v2;
<a name="l00093"></a>00093         m_vertices[v1].AddEdge(name);
<a name="l00094"></a>00094         m_vertices[v2].AddEdge(name);
<a name="l00095"></a>00095         m_nE++;
<a name="l00096"></a>00096                 <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">long</span><span class="keyword">&gt;</span>(name);
<a name="l00097"></a>00097     }
<a name="l00098"></a>00098 
<a name="l00099"></a><a class="code" href="class_h_a_c_d_1_1_graph.html#aad2bfb7cdd25accd0895435c3c357447">00099</a>     <span class="keywordtype">bool</span> <a class="code" href="class_h_a_c_d_1_1_graph.html#aad2bfb7cdd25accd0895435c3c357447">Graph::DeleteEdge</a>(<span class="keywordtype">long</span> name)
<a name="l00100"></a>00100     {
<a name="l00101"></a>00101                 <span class="keywordflow">if</span> (name &lt; static_cast&lt;long&gt;(m_edges.size()))
<a name="l00102"></a>00102                 {
<a name="l00103"></a>00103             <span class="keywordtype">long</span> v1 = m_edges[name].m_v1;
<a name="l00104"></a>00104             <span class="keywordtype">long</span> v2 = m_edges[name].m_v2;
<a name="l00105"></a>00105                         m_edges[name].m_deleted = <span class="keyword">true</span>;
<a name="l00106"></a>00106             m_vertices[v1].DeleteEdge(name);
<a name="l00107"></a>00107             m_vertices[v2].DeleteEdge(name);
<a name="l00108"></a>00108 <span class="comment">//                      m_edges[name].m_pointsCH.clear();</span>
<a name="l00109"></a>00109             <span class="keyword">delete</span> m_edges[name].m_convexHull;
<a name="l00110"></a>00110                         m_edges[name].m_distPoints.clear();
<a name="l00111"></a>00111             m_edges[name].m_convexHull = 0;
<a name="l00112"></a>00112                         m_nE--;
<a name="l00113"></a>00113                         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00114"></a>00114                 }
<a name="l00115"></a>00115                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00116"></a>00116     }
<a name="l00117"></a><a class="code" href="class_h_a_c_d_1_1_graph.html#a68da8b8b89ffe0d7398dbb1cf5e29745">00117</a>     <span class="keywordtype">bool</span> <a class="code" href="class_h_a_c_d_1_1_graph.html#a68da8b8b89ffe0d7398dbb1cf5e29745">Graph::DeleteVertex</a>(<span class="keywordtype">long</span> name)
<a name="l00118"></a>00118     {
<a name="l00119"></a>00119                 <span class="keywordflow">if</span> (name &lt; static_cast&lt;long&gt;(m_vertices.size()))
<a name="l00120"></a>00120                 {
<a name="l00121"></a>00121                         m_vertices[name].m_deleted = <span class="keyword">true</span>;
<a name="l00122"></a>00122             m_vertices[name].m_edges.clear();
<a name="l00123"></a>00123             m_vertices[name].m_ancestors = std::vector&lt;long&gt;();
<a name="l00124"></a>00124             <span class="keyword">delete</span> m_vertices[name].m_convexHull;
<a name="l00125"></a>00125                         m_vertices[name].m_distPoints.clear();
<a name="l00126"></a>00126             m_vertices[name].m_convexHull = 0;
<a name="l00127"></a>00127                         m_nV--;
<a name="l00128"></a>00128                         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00129"></a>00129                 }
<a name="l00130"></a>00130                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00131"></a>00131     }    
<a name="l00132"></a><a class="code" href="class_h_a_c_d_1_1_graph.html#acecb11031d9404fcfe62d6c2d3323428">00132</a>     <span class="keywordtype">bool</span> <a class="code" href="class_h_a_c_d_1_1_graph.html#acecb11031d9404fcfe62d6c2d3323428">Graph::EdgeCollapse</a>(<span class="keywordtype">long</span> v1, <span class="keywordtype">long</span> v2)
<a name="l00133"></a>00133         {
<a name="l00134"></a>00134                 <span class="keywordtype">long</span> edgeToDelete = <a class="code" href="class_h_a_c_d_1_1_graph.html#a60f3806e9eb15792e1bb4c9ea4742b9f">GetEdgeID</a>(v1, v2);
<a name="l00135"></a>00135         <span class="keywordflow">if</span> (edgeToDelete &gt;= 0) 
<a name="l00136"></a>00136                 {
<a name="l00137"></a>00137                         <span class="comment">// delete the edge (v1, v2)</span>
<a name="l00138"></a>00138                         <a class="code" href="class_h_a_c_d_1_1_graph.html#aad2bfb7cdd25accd0895435c3c357447">DeleteEdge</a>(edgeToDelete);
<a name="l00139"></a>00139                         <span class="comment">// add v2 to v1 ancestors</span>
<a name="l00140"></a>00140             m_vertices[v1].m_ancestors.push_back(v2);
<a name="l00141"></a>00141                         <span class="comment">// add v2&#39;s ancestors to v1&#39;s ancestors</span>
<a name="l00142"></a>00142                         m_vertices[v1].m_ancestors.insert(m_vertices[v1].m_ancestors.begin(),
<a name="l00143"></a>00143                                                                                           m_vertices[v2].m_ancestors.begin(), 
<a name="l00144"></a>00144                                                                                           m_vertices[v2].m_ancestors.end());
<a name="l00145"></a>00145                         <span class="comment">// update adjacency information</span>
<a name="l00146"></a>00146                         std::set&lt;long&gt; &amp; v1Edges =  m_vertices[v1].m_edges;
<a name="l00147"></a>00147                         std::set&lt;long&gt;::const_iterator ed(m_vertices[v2].m_edges.begin());
<a name="l00148"></a>00148                         std::set&lt;long&gt;::const_iterator itEnd(m_vertices[v2].m_edges.end());
<a name="l00149"></a>00149                         <span class="keywordtype">long</span> b = -1;
<a name="l00150"></a>00150                         <span class="keywordflow">for</span>(; ed != itEnd; ++ed) 
<a name="l00151"></a>00151                         {
<a name="l00152"></a>00152                                 <span class="keywordflow">if</span> (m_edges[*ed].m_v1 == v2)
<a name="l00153"></a>00153                                 {
<a name="l00154"></a>00154                                         b = m_edges[*ed].m_v2;
<a name="l00155"></a>00155                                 }
<a name="l00156"></a>00156                                 <span class="keywordflow">else</span>
<a name="l00157"></a>00157                                 {
<a name="l00158"></a>00158                                         b = m_edges[*ed].m_v1;
<a name="l00159"></a>00159                                 }
<a name="l00160"></a>00160                                 <span class="keywordflow">if</span> (<a class="code" href="class_h_a_c_d_1_1_graph.html#a60f3806e9eb15792e1bb4c9ea4742b9f">GetEdgeID</a>(v1, b) &gt;= 0)
<a name="l00161"></a>00161                                 {
<a name="l00162"></a>00162                                         m_edges[*ed].m_deleted = <span class="keyword">true</span>;
<a name="l00163"></a>00163                                         m_vertices[b].DeleteEdge(*ed);
<a name="l00164"></a>00164                                         m_nE--;
<a name="l00165"></a>00165                                 }
<a name="l00166"></a>00166                                 <span class="keywordflow">else</span>
<a name="l00167"></a>00167                                 {
<a name="l00168"></a>00168                                         m_edges[*ed].m_v1 = v1;
<a name="l00169"></a>00169                                         m_edges[*ed].m_v2 = b;
<a name="l00170"></a>00170                                         v1Edges.insert(*ed);
<a name="l00171"></a>00171                                 }
<a name="l00172"></a>00172                         }
<a name="l00173"></a>00173                         <span class="comment">// delete the vertex v2</span>
<a name="l00174"></a>00174             <a class="code" href="class_h_a_c_d_1_1_graph.html#a68da8b8b89ffe0d7398dbb1cf5e29745">DeleteVertex</a>(v2);                   
<a name="l00175"></a>00175             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00176"></a>00176         }
<a name="l00177"></a>00177                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00178"></a>00178     }
<a name="l00179"></a>00179     
<a name="l00180"></a><a class="code" href="class_h_a_c_d_1_1_graph.html#a60f3806e9eb15792e1bb4c9ea4742b9f">00180</a>     <span class="keywordtype">long</span> <a class="code" href="class_h_a_c_d_1_1_graph.html#a60f3806e9eb15792e1bb4c9ea4742b9f">Graph::GetEdgeID</a>(<span class="keywordtype">long</span> v1, <span class="keywordtype">long</span> v2)<span class="keyword"> const</span>
<a name="l00181"></a>00181 <span class="keyword">    </span>{
<a name="l00182"></a>00182                 <span class="keywordflow">if</span> (v1 &lt; static_cast&lt;long&gt;(m_vertices.size()) &amp;&amp; !m_vertices[v1].m_deleted)
<a name="l00183"></a>00183                 {
<a name="l00184"></a>00184                         std::set&lt;long&gt;::const_iterator ed(m_vertices[v1].m_edges.begin());
<a name="l00185"></a>00185                         std::set&lt;long&gt;::const_iterator itEnd(m_vertices[v1].m_edges.end());
<a name="l00186"></a>00186                         <span class="keywordflow">for</span>(; ed != itEnd; ++ed) 
<a name="l00187"></a>00187                         {
<a name="l00188"></a>00188                                 <span class="keywordflow">if</span> ( (m_edges[*ed].m_v1 == v2) || 
<a name="l00189"></a>00189                                          (m_edges[*ed].m_v2 == v2)   ) 
<a name="l00190"></a>00190                                 {
<a name="l00191"></a>00191                                         <span class="keywordflow">return</span> m_edges[*ed].m_name;
<a name="l00192"></a>00192                                 }
<a name="l00193"></a>00193                         }
<a name="l00194"></a>00194                 }
<a name="l00195"></a>00195         <span class="keywordflow">return</span> -1;
<a name="l00196"></a>00196     }
<a name="l00197"></a>00197     
<a name="l00198"></a><a class="code" href="class_h_a_c_d_1_1_graph.html#ab828956cb835d484e71c4e99a28c6d6f">00198</a>     <span class="keywordtype">long</span> <a class="code" href="class_h_a_c_d_1_1_graph.html#ab828956cb835d484e71c4e99a28c6d6f">Graph::ExtractCCs</a>()
<a name="l00199"></a>00199         {
<a name="l00200"></a>00200         <span class="comment">// all CCs to -1</span>
<a name="l00201"></a>00201         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> v = 0; v &lt; m_vertices.size(); ++v) 
<a name="l00202"></a>00202                 {
<a name="l00203"></a>00203                         <span class="keywordflow">if</span> (!m_vertices[v].m_deleted)
<a name="l00204"></a>00204                         {
<a name="l00205"></a>00205                                 m_vertices[v].m_cc = -1;
<a name="l00206"></a>00206                         }
<a name="l00207"></a>00207         }
<a name="l00208"></a>00208         
<a name="l00209"></a>00209         <span class="comment">// we get the CCs</span>
<a name="l00210"></a>00210         m_nCCs = 0;
<a name="l00211"></a>00211                 <span class="keywordtype">long</span> v2 = -1;
<a name="l00212"></a>00212                 std::vector&lt;long&gt; temp;
<a name="l00213"></a>00213         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> v = 0; v &lt; m_vertices.size(); ++v) 
<a name="l00214"></a>00214                 {
<a name="l00215"></a>00215                         <span class="keywordflow">if</span> (!m_vertices[v].m_deleted &amp;&amp; m_vertices[v].m_cc == -1) 
<a name="l00216"></a>00216                         {
<a name="l00217"></a>00217                 m_vertices[v].m_cc = m_nCCs;
<a name="l00218"></a>00218                 temp.clear();
<a name="l00219"></a>00219                 temp.push_back(m_vertices[v].m_name);
<a name="l00220"></a>00220                 <span class="keywordflow">while</span> (temp.size()) 
<a name="l00221"></a>00221                                 {
<a name="l00222"></a>00222                     <span class="keywordtype">long</span> vertex = temp[temp.size()-1];
<a name="l00223"></a>00223                     temp.pop_back();                    
<a name="l00224"></a>00224                                         std::set&lt;long&gt;::const_iterator ed(m_vertices[vertex].m_edges.begin());
<a name="l00225"></a>00225                                         std::set&lt;long&gt;::const_iterator itEnd(m_vertices[vertex].m_edges.end());
<a name="l00226"></a>00226                                         <span class="keywordflow">for</span>(; ed != itEnd; ++ed) 
<a name="l00227"></a>00227                                         {
<a name="l00228"></a>00228                         <span class="keywordflow">if</span> (m_edges[*ed].m_v1 == vertex) 
<a name="l00229"></a>00229                                                 {
<a name="l00230"></a>00230                             v2 = m_edges[*ed].m_v2;
<a name="l00231"></a>00231                         }
<a name="l00232"></a>00232                         <span class="keywordflow">else</span> 
<a name="l00233"></a>00233                                                 {
<a name="l00234"></a>00234                             v2 = m_edges[*ed].m_v1;
<a name="l00235"></a>00235                         }
<a name="l00236"></a>00236                         <span class="keywordflow">if</span> ( !m_vertices[v2].m_deleted &amp;&amp; m_vertices[v2].m_cc == -1) 
<a name="l00237"></a>00237                                                 {
<a name="l00238"></a>00238                             m_vertices[v2].m_cc = m_nCCs;
<a name="l00239"></a>00239                             temp.push_back(v2);
<a name="l00240"></a>00240                         }
<a name="l00241"></a>00241                     }
<a name="l00242"></a>00242                 }
<a name="l00243"></a>00243                 m_nCCs++;
<a name="l00244"></a>00244             }
<a name="l00245"></a>00245         }        
<a name="l00246"></a>00246         <span class="keywordflow">return</span> m_nCCs;
<a name="l00247"></a>00247     }
<a name="l00248"></a><a class="code" href="class_h_a_c_d_1_1_graph.html#ada40569f2d9cd18d80b7644465c481c6">00248</a>     <span class="keywordtype">void</span> <a class="code" href="class_h_a_c_d_1_1_graph.html#ada40569f2d9cd18d80b7644465c481c6">Graph::ConnectCCs</a>()
<a name="l00249"></a>00249         {
<a name="l00250"></a>00250         <a class="code" href="class_h_a_c_d_1_1_graph.html#ab828956cb835d484e71c4e99a28c6d6f">ExtractCCs</a>();
<a name="l00251"></a>00251                 std::vector&lt;long&gt; clustersRep;
<a name="l00252"></a>00252                 clustersRep.resize(m_nCCs, -1);
<a name="l00253"></a>00253                 <span class="keywordtype">size_t</span> done = 0;
<a name="l00254"></a>00254         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> v = 0; (done&lt;m_nCCs) &amp;&amp; (v &lt; m_vertices.size()); ++v) 
<a name="l00255"></a>00255                 {
<a name="l00256"></a>00256                         <span class="keywordflow">if</span> (!m_vertices[v].m_deleted &amp;&amp; m_vertices[v].m_cc &gt;=0 &amp;&amp; clustersRep[m_vertices[v].m_cc] == -1)
<a name="l00257"></a>00257                         {
<a name="l00258"></a>00258                                 clustersRep[m_vertices[v].m_cc] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">long</span><span class="keyword">&gt;</span>(v);
<a name="l00259"></a>00259                                 done++;
<a name="l00260"></a>00260                         }
<a name="l00261"></a>00261         }
<a name="l00262"></a>00262         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; m_nCCs; i++) 
<a name="l00263"></a>00263                 {
<a name="l00264"></a>00264             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = i+1; j &lt; m_nCCs; j++) 
<a name="l00265"></a>00265                         {
<a name="l00266"></a>00266                 <a class="code" href="class_h_a_c_d_1_1_graph.html#a0d079952cce618a81fb46c13910d0109">AddEdge</a>(clustersRep[i], clustersRep[j]);
<a name="l00267"></a>00267             }
<a name="l00268"></a>00268                 }
<a name="l00269"></a>00269     }
<a name="l00270"></a><a class="code" href="class_h_a_c_d_1_1_graph.html#a1144b794bf4a88c78808c4841549f5da">00270</a>         <span class="keywordtype">void</span> <a class="code" href="class_h_a_c_d_1_1_graph.html#a1144b794bf4a88c78808c4841549f5da">Graph::Print</a>()<span class="keyword"> const</span>
<a name="l00271"></a>00271 <span class="keyword">        </span>{
<a name="l00272"></a>00272                 std::cout &lt;&lt; <span class="stringliteral">&quot;-----------------------------&quot;</span> &lt;&lt; std::endl;
<a name="l00273"></a>00273         std::cout &lt;&lt; <span class="stringliteral">&quot;vertices (&quot;</span> &lt;&lt; m_nV &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;
<a name="l00274"></a>00274         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> v = 0; v &lt; m_vertices.size(); ++v) 
<a name="l00275"></a>00275                 {
<a name="l00276"></a>00276                         <span class="keyword">const</span> <a class="code" href="class_h_a_c_d_1_1_graph_vertex.html">GraphVertex</a> &amp; currentVertex = m_vertices[v];
<a name="l00277"></a>00277                         <span class="keywordflow">if</span> (!m_vertices[v].m_deleted)
<a name="l00278"></a>00278                         {
<a name="l00279"></a>00279 
<a name="l00280"></a>00280                                 std::cout  &lt;&lt; currentVertex.m_name        &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> 
<a name="l00281"></a>00281                                                    &lt;&lt; currentVertex.m_cc &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00282"></a>00282                                 std::set&lt;long&gt;::const_iterator ed(currentVertex.m_edges.begin());
<a name="l00283"></a>00283                                 std::set&lt;long&gt;::const_iterator itEnd(currentVertex.m_edges.end());
<a name="l00284"></a>00284                                 <span class="keywordflow">for</span>(; ed != itEnd; ++ed) 
<a name="l00285"></a>00285                                 {
<a name="l00286"></a>00286                                         std::cout  &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; m_edges[*ed].m_v1 &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; m_edges[*ed].m_v2 &lt;&lt; <span class="stringliteral">&quot;) &quot;</span>;       
<a name="l00287"></a>00287                                 }
<a name="l00288"></a>00288                                 std::cout &lt;&lt; std::endl;
<a name="l00289"></a>00289                         }                       
<a name="l00290"></a>00290                 }
<a name="l00291"></a>00291 
<a name="l00292"></a>00292                 std::cout &lt;&lt; <span class="stringliteral">&quot;vertices (&quot;</span> &lt;&lt; m_nE &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;
<a name="l00293"></a>00293                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> e = 0; e &lt; m_edges.size(); ++e) 
<a name="l00294"></a>00294                 {
<a name="l00295"></a>00295                         <span class="keyword">const</span> <a class="code" href="class_h_a_c_d_1_1_graph_edge.html">GraphEdge</a> &amp; currentEdge = m_edges[e];
<a name="l00296"></a>00296                         <span class="keywordflow">if</span> (!m_edges[e].m_deleted)
<a name="l00297"></a>00297                         {
<a name="l00298"></a>00298                                 std::cout  &lt;&lt; currentEdge.m_name          &lt;&lt; <span class="stringliteral">&quot;\t(&quot;</span> 
<a name="l00299"></a>00299                                                    &lt;&lt; m_edges[e].m_v1             &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> 
<a name="l00300"></a>00300                                                    &lt;&lt; m_edges[e].m_v2             &lt;&lt; <span class="stringliteral">&quot;) &quot;</span>&lt;&lt; std::endl;
<a name="l00301"></a>00301                         }                       
<a name="l00302"></a>00302                 }
<a name="l00303"></a>00303         }
<a name="l00304"></a><a class="code" href="class_h_a_c_d_1_1_graph.html#a635da6550681de9e779c2deda2a282c1">00304</a>         <span class="keywordtype">void</span> <a class="code" href="class_h_a_c_d_1_1_graph.html#a635da6550681de9e779c2deda2a282c1">Graph::Clear</a>()
<a name="l00305"></a>00305         {
<a name="l00306"></a>00306                 m_vertices.clear();
<a name="l00307"></a>00307                 m_edges.clear();
<a name="l00308"></a>00308                 m_nV = 0;
<a name="l00309"></a>00309         m_nE = 0;
<a name="l00310"></a>00310         m_nCCs = 0;
<a name="l00311"></a>00311         }
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 }
</pre></div></div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Mon May 2 2011 15:54:21 for HACD by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
