<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>HACD: C:/Users/kmammou/Dev/HACD/src/HACD_Lib/src/hacdHACD.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">HACD&#160;<span id="projectnumber">0.0.1</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">C:/Users/kmammou/Dev/HACD/src/HACD_Lib/src/hacdHACD.cpp</div>  </div>
</div>
<div class="contents">
<a href="hacd_h_a_c_d_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Copyright (c) 2011 Khaled Mamou (kmamou at gmail dot com)</span>
<a name="l00002"></a>00002 <span class="comment"> All rights reserved.</span>
<a name="l00003"></a>00003 <span class="comment"> </span>
<a name="l00004"></a>00004 <span class="comment"> </span>
<a name="l00005"></a>00005 <span class="comment"> Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment"> </span>
<a name="l00007"></a>00007 <span class="comment"> 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00008"></a>00008 <span class="comment"> </span>
<a name="l00009"></a>00009 <span class="comment"> 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00010"></a>00010 <span class="comment"> </span>
<a name="l00011"></a>00011 <span class="comment"> 3. The names of the contributors may not be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00012"></a>00012 <span class="comment"> </span>
<a name="l00013"></a>00013 <span class="comment"> THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00014"></a>00014 <span class="comment"> */</span>
<a name="l00015"></a><a class="code" href="hacd_h_a_c_d_8cpp.html#af08ec37a8c99d747fb60fa15bc28678b">00015</a> <span class="preprocessor">#define _CRT_SECURE_NO_WARNINGS</span>
<a name="l00016"></a>00016 <span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="hacd_graph_8h.html">hacdGraph.h</a>&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;<a class="code" href="hacd_h_a_c_d_8h.html">hacdHACD.h</a>&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;<a class="code" href="hacd_i_c_hull_8h.html">hacdICHull.h</a>&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00020"></a>00020 <span class="keyword">namespace </span>HACD
<a name="l00021"></a>00021 { 
<a name="l00022"></a>00022     
<a name="l00023"></a>00023         <span class="keywordtype">double</span>  HACD::Concavity(ICHull &amp; ch, std::map&lt;long, DPoint&gt; &amp; distPoints)
<a name="l00024"></a>00024     {
<a name="l00025"></a>00025                 TMMesh &amp; meshCH = ch.GetMesh();
<a name="l00026"></a>00026                 <span class="keywordtype">double</span> concavity = 0.0;
<a name="l00027"></a>00027                 <span class="keywordtype">double</span> distance = 0.0;       
<a name="l00028"></a>00028                 std::map&lt;long, DPoint&gt;::iterator itDP(distPoints.begin());
<a name="l00029"></a>00029                 std::map&lt;long, DPoint&gt;::iterator itDPEnd(distPoints.end());
<a name="l00030"></a>00030                 std::map&lt;long, DPoint&gt;::iterator itDP1;
<a name="l00031"></a>00031                 <span class="keywordflow">for</span>(; itDP != itDPEnd; ++itDP) 
<a name="l00032"></a>00032                 {
<a name="l00033"></a>00033                         <span class="keywordflow">if</span> (!(itDP-&gt;second).m_computed)
<a name="l00034"></a>00034                         {
<a name="l00035"></a>00035                                 (itDP-&gt;second).m_dist = meshCH.ComputeDistance(itDP-&gt;first, m_points[itDP-&gt;first],  
<a name="l00036"></a>00036                                                                                                                           m_normals[itDP-&gt;first], 
<a name="l00037"></a>00037                                                                                                                           (itDP-&gt;second).m_computed, <span class="keyword">true</span>);
<a name="l00038"></a>00038                         }
<a name="l00039"></a>00039                         distance = (itDP-&gt;second).m_dist;
<a name="l00040"></a>00040                         concavity = std::max&lt;double&gt;(concavity, distance);
<a name="l00041"></a>00041                 }
<a name="l00042"></a>00042                 <span class="keywordflow">return</span> concavity;
<a name="l00043"></a>00043     }
<a name="l00044"></a>00044     <span class="keywordtype">double</span> HACD::ComputePerimeter(<span class="keyword">const</span> std::vector&lt;long&gt; &amp; triIndices)<span class="keyword"> const</span>
<a name="l00045"></a>00045 <span class="keyword">    </span>{
<a name="l00046"></a>00046         <span class="keyword">const</span> <span class="keywordtype">size_t</span> nTriangles = triIndices.size();
<a name="l00047"></a>00047                 std::map&lt;unsigned long long, long&gt; edges;
<a name="l00048"></a>00048         <span class="keywordtype">long</span> p;
<a name="l00049"></a>00049         <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; nTriangles;++i)
<a name="l00050"></a>00050         {
<a name="l00051"></a>00051             p = triIndices[i];
<a name="l00052"></a>00052                         edges[GetEdgeIndex(m_triangles[p].X(), m_triangles[p].Y())]++;
<a name="l00053"></a>00053                         edges[GetEdgeIndex(m_triangles[p].X(), m_triangles[p].Z())]++;
<a name="l00054"></a>00054                         edges[GetEdgeIndex(m_triangles[p].Z(), m_triangles[p].Y())]++;
<a name="l00055"></a>00055         }
<a name="l00056"></a>00056         
<a name="l00057"></a>00057         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> v1, v2;
<a name="l00058"></a>00058         <span class="keywordtype">double</span> perimeter = 0;
<a name="l00059"></a>00059                 Vec3&lt;double&gt; u;
<a name="l00060"></a>00060                 <span class="keyword">const</span> std::map&lt;unsigned long long, long&gt;::iterator itEnd = edges.end();
<a name="l00061"></a>00061         <span class="keywordflow">for</span>(std::map&lt;unsigned long long, long&gt;::iterator it = edges.begin(); it != itEnd; ++it)
<a name="l00062"></a>00062         {
<a name="l00063"></a>00063             <span class="keywordflow">if</span> (it-&gt;second == 1)
<a name="l00064"></a>00064             {
<a name="l00065"></a>00065                 v1 = <span class="keyword">static_cast&lt;</span><span class="keywordtype">long</span><span class="keyword">&gt;</span>((it-&gt;first) &gt;&gt; 32);
<a name="l00066"></a>00066                 v2 = <span class="keyword">static_cast&lt;</span><span class="keywordtype">long</span><span class="keyword">&gt;</span>((it-&gt;first) &amp; 0xFFFFFFFFULL);
<a name="l00067"></a>00067                                 u = m_points[v1] - m_points[v2];
<a name="l00068"></a>00068                 perimeter += u.GetNorm();
<a name="l00069"></a>00069             }
<a name="l00070"></a>00070         }
<a name="l00071"></a>00071         <span class="keywordflow">return</span> perimeter;
<a name="l00072"></a>00072     }
<a name="l00073"></a>00073 
<a name="l00074"></a>00074         <span class="keywordtype">void</span> HACD::ComputeV2T()
<a name="l00075"></a>00075         {
<a name="l00076"></a>00076                 m_v2T.clear();
<a name="l00077"></a>00077                 m_v2T.resize(m_nPoints);
<a name="l00078"></a>00078                 <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> t = 0; t &lt; m_nTriangles; ++t)
<a name="l00079"></a>00079                 {
<a name="l00080"></a>00080                         m_v2T[m_triangles[t].X()].insert(t);
<a name="l00081"></a>00081                         m_v2T[m_triangles[t].Y()].insert(t);
<a name="l00082"></a>00082                         m_v2T[m_triangles[t].Z()].insert(t);
<a name="l00083"></a>00083                 }
<a name="l00084"></a>00084         }
<a name="l00085"></a>00085     <span class="keywordtype">void</span> HACD::CreateGraph(<span class="keywordtype">bool</span> connectCCs)
<a name="l00086"></a>00086     {
<a name="l00087"></a>00087                 ComputeV2T();
<a name="l00088"></a>00088                 m_graph.Clear();
<a name="l00089"></a>00089                 m_graph.Allocate(m_nTriangles, 3 * m_nTriangles);
<a name="l00090"></a>00090                 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> tr1[3];
<a name="l00091"></a>00091                 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> tr2[3];
<a name="l00092"></a>00092         <span class="keywordtype">long</span> i1, j1, k1, i2, j2, k2;
<a name="l00093"></a>00093         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> v = 0; v &lt; m_nPoints; v++) 
<a name="l00094"></a>00094                 {
<a name="l00095"></a>00095                         std::set&lt;long&gt;::const_iterator it1(m_v2T[v].begin()), itEnd(m_v2T[v].end()); 
<a name="l00096"></a>00096                         <span class="keywordflow">for</span>(; it1 != itEnd; ++it1)
<a name="l00097"></a>00097                         {
<a name="l00098"></a>00098                 i1 = m_triangles[*it1].X();
<a name="l00099"></a>00099                 j1 = m_triangles[*it1].Y();
<a name="l00100"></a>00100                 k1 = m_triangles[*it1].Z();
<a name="l00101"></a>00101                                 tr1[0] = GetEdgeIndex(i1, j1);
<a name="l00102"></a>00102                                 tr1[1] = GetEdgeIndex(j1, k1);
<a name="l00103"></a>00103                                 tr1[2] = GetEdgeIndex(k1, i1);
<a name="l00104"></a>00104                                 std::set&lt;long&gt;::const_iterator it2(it1);
<a name="l00105"></a>00105                                 <span class="keywordflow">for</span>(++it2; it2 != itEnd; ++it2)
<a name="l00106"></a>00106                                 {
<a name="l00107"></a>00107                     i2 = m_triangles[*it2].X();
<a name="l00108"></a>00108                     j2 = m_triangles[*it2].Y();
<a name="l00109"></a>00109                     k2 = m_triangles[*it2].Z();
<a name="l00110"></a>00110                                         tr2[0] = GetEdgeIndex(i2, j2);
<a name="l00111"></a>00111                                         tr2[1] = GetEdgeIndex(j2, k2);
<a name="l00112"></a>00112                                         tr2[2] = GetEdgeIndex(k2, i2);
<a name="l00113"></a>00113                                         <span class="keywordtype">bool</span> done = <span class="keyword">false</span>;
<a name="l00114"></a>00114                                         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 3 &amp;&amp; !done; ++i)
<a name="l00115"></a>00115                                         {
<a name="l00116"></a>00116                                                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 3; ++j)
<a name="l00117"></a>00117                                                 {
<a name="l00118"></a>00118                                                         <span class="keywordflow">if</span> (tr1[i] == tr2[j])   <span class="comment">// two triangles are connected if they share at least an edge</span>
<a name="l00119"></a>00119                                                         {
<a name="l00120"></a>00120                                                                 m_graph.AddEdge(*it1, *it2);
<a name="l00121"></a>00121                                                                 done = <span class="keyword">true</span>;
<a name="l00122"></a>00122                                                                 <span class="keywordflow">break</span>;
<a name="l00123"></a>00123                                                         }
<a name="l00124"></a>00124                                                 }
<a name="l00125"></a>00125                                         }
<a name="l00126"></a>00126                                         
<a name="l00127"></a>00127                                 }
<a name="l00128"></a>00128                         }
<a name="l00129"></a>00129         }
<a name="l00130"></a>00130                 <span class="comment">// free memory;</span>
<a name="l00131"></a>00131                 m_v2T = std::vector&lt; std::set&lt;long&gt; &gt;();
<a name="l00132"></a>00132         
<a name="l00133"></a>00133         <span class="keywordflow">if</span> (connectCCs) 
<a name="l00134"></a>00134                 {
<a name="l00135"></a>00135                         m_graph.ConnectCCs();
<a name="l00136"></a>00136                 }
<a name="l00137"></a>00137     }
<a name="l00138"></a>00138     <span class="keywordtype">void</span> HACD::InitializeGraph()
<a name="l00139"></a>00139     {
<a name="l00140"></a>00140         <span class="keywordtype">long</span> i, j, k;
<a name="l00141"></a>00141         Vec3&lt;double&gt; u, v, w, normal;
<a name="l00142"></a>00142                 <span class="keyword">delete</span> [] m_normals;
<a name="l00143"></a>00143                 m_normals = <span class="keyword">new</span> Vec3&lt;double&gt;[m_nPoints];
<a name="l00144"></a>00144 
<a name="l00145"></a>00145                 memset(m_normals, 0, <span class="keyword">sizeof</span>(Vec3&lt;double&gt;) * m_nPoints);
<a name="l00146"></a>00146         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> f = 0; f &lt; m_nTriangles; f++)
<a name="l00147"></a>00147         {
<a name="l00148"></a>00148             i = m_triangles[f].X();
<a name="l00149"></a>00149             j = m_triangles[f].Y();
<a name="l00150"></a>00150             k = m_triangles[f].Z();
<a name="l00151"></a>00151                 
<a name="l00152"></a>00152                         m_graph.m_vertices[f].m_distPoints[i];
<a name="l00153"></a>00153                         m_graph.m_vertices[f].m_distPoints[j];
<a name="l00154"></a>00154                         m_graph.m_vertices[f].m_distPoints[k];
<a name="l00155"></a>00155             
<a name="l00156"></a>00156             ICHull  * ch = <span class="keyword">new</span> ICHull;
<a name="l00157"></a>00157             m_graph.m_vertices[f].m_convexHull = ch;
<a name="l00158"></a>00158             ch-&gt;AddPoint(m_points[i], i);
<a name="l00159"></a>00159             ch-&gt;AddPoint(m_points[j], j);
<a name="l00160"></a>00160             ch-&gt;AddPoint(m_points[k], k);
<a name="l00161"></a>00161                         ch-&gt;SetDistPoints(&amp;m_graph.m_vertices[f].m_distPoints);
<a name="l00162"></a>00162 
<a name="l00163"></a>00163                         u = m_points[j] - m_points[i];
<a name="l00164"></a>00164                         v = m_points[k] - m_points[i];
<a name="l00165"></a>00165                         w = m_points[k] - m_points[j];
<a name="l00166"></a>00166                         normal = - u ^ v;
<a name="l00167"></a>00167 
<a name="l00168"></a>00168                         m_normals[i] += normal;
<a name="l00169"></a>00169                         m_normals[j] += normal;
<a name="l00170"></a>00170                         m_normals[k] += normal;
<a name="l00171"></a>00171 
<a name="l00172"></a>00172                         m_graph.m_vertices[f].m_surf = normal.GetNorm();
<a name="l00173"></a>00173                         m_graph.m_vertices[f].m_perimeter = u.GetNorm() + v.GetNorm() + w.GetNorm();
<a name="l00174"></a>00174         }
<a name="l00175"></a>00175         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> v = 0; v &lt; m_nPoints; v++) 
<a name="l00176"></a>00176                 {
<a name="l00177"></a>00177                         m_normals[v].Normalize();
<a name="l00178"></a>00178                 }
<a name="l00179"></a>00179     }
<a name="l00180"></a>00180 
<a name="l00181"></a>00181         <span class="keywordtype">void</span> HACD::NormalizeData()
<a name="l00182"></a>00182         {
<a name="l00183"></a>00183                 <span class="keywordflow">if</span> (m_nPoints == 0)
<a name="l00184"></a>00184                 {
<a name="l00185"></a>00185                         <span class="keywordflow">return</span>;
<a name="l00186"></a>00186                 }
<a name="l00187"></a>00187 
<a name="l00188"></a>00188         m_barycenter = m_points[0];
<a name="l00189"></a>00189                 Vec3&lt;double&gt; min = m_points[0];
<a name="l00190"></a>00190                 Vec3&lt;double&gt; max = m_points[0];
<a name="l00191"></a>00191                 <span class="keywordtype">double</span> x, y, z;
<a name="l00192"></a>00192         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> v = 1; v &lt; m_nPoints ; v++) 
<a name="l00193"></a>00193         {
<a name="l00194"></a>00194                         m_barycenter += m_points[v];
<a name="l00195"></a>00195             x = m_points[v].X();
<a name="l00196"></a>00196             y = m_points[v].Y();
<a name="l00197"></a>00197             z = m_points[v].Z();
<a name="l00198"></a>00198             <span class="keywordflow">if</span> ( x &lt; min.X()) min.X() = x;
<a name="l00199"></a>00199                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( x &gt; max.X()) max.X() = x;
<a name="l00200"></a>00200             <span class="keywordflow">if</span> ( y &lt; min.Y()) min.Y() = y;
<a name="l00201"></a>00201                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( y &gt; max.Y()) max.Y() = y;
<a name="l00202"></a>00202             <span class="keywordflow">if</span> ( z &lt; min.Z()) min.Z() = z;
<a name="l00203"></a>00203                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( z &gt; max.Z()) max.Z() = z;
<a name="l00204"></a>00204         }
<a name="l00205"></a>00205                 m_barycenter /= m_nPoints;
<a name="l00206"></a>00206         m_diag = (max-min).GetNorm();
<a name="l00207"></a>00207         <span class="keywordtype">double</span> invDiag = 1.0 / m_diag;
<a name="l00208"></a>00208                 <span class="keywordflow">if</span> (m_diag != 0.0)
<a name="l00209"></a>00209                 {
<a name="l00210"></a>00210                         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> v = 0; v &lt; m_nPoints ; v++) 
<a name="l00211"></a>00211                         {
<a name="l00212"></a>00212                                 m_points[v] = (m_points[v] - m_barycenter) * invDiag;
<a name="l00213"></a>00213                         }
<a name="l00214"></a>00214                 }
<a name="l00215"></a>00215     }
<a name="l00216"></a>00216         <span class="keywordtype">void</span> HACD::DenormalizeData()
<a name="l00217"></a>00217         {
<a name="l00218"></a>00218                 <span class="keywordflow">if</span> (m_nPoints == 0)
<a name="l00219"></a>00219                 {
<a name="l00220"></a>00220                         <span class="keywordflow">return</span>;
<a name="l00221"></a>00221                 }
<a name="l00222"></a>00222                 <span class="keywordflow">if</span> (m_diag != 0.0)
<a name="l00223"></a>00223                 {
<a name="l00224"></a>00224                         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> v = 0; v &lt; m_nPoints ; v++) 
<a name="l00225"></a>00225                         {
<a name="l00226"></a>00226                                 m_points[v] = m_points[v] * m_diag + m_barycenter;
<a name="l00227"></a>00227                         }
<a name="l00228"></a>00228                 }
<a name="l00229"></a>00229     }
<a name="l00230"></a><a class="code" href="class_h_a_c_d_1_1_h_a_c_d.html#a8b8afc4c214d7fef80765c7b3a1ee973">00230</a>         <a class="code" href="class_h_a_c_d_1_1_h_a_c_d.html#a8b8afc4c214d7fef80765c7b3a1ee973">HACD::HACD</a>(<span class="keywordtype">void</span>)
<a name="l00231"></a>00231         {
<a name="l00232"></a>00232         m_convexHulls = 0;
<a name="l00233"></a>00233                 m_triangles = 0;
<a name="l00234"></a>00234         m_points = 0;
<a name="l00235"></a>00235         m_normals = 0;
<a name="l00236"></a>00236         m_nTriangles = 0;
<a name="l00237"></a>00237         m_nPoints = 0;
<a name="l00238"></a>00238         m_nClusters = 0;
<a name="l00239"></a>00239         m_concavity = 0.0;
<a name="l00240"></a>00240         m_diag = 1.0;
<a name="l00241"></a>00241                 m_barycenter = <a class="code" href="class_h_a_c_d_1_1_vec3.html">Vec3&lt;double&gt;</a>(0.0, 0.0,0.0);
<a name="l00242"></a>00242         m_alpha = pow(10.0, -12.0);
<a name="l00243"></a>00243         m_nVerticesPerCH = 30;
<a name="l00244"></a>00244                 m_callBack = 0;
<a name="l00245"></a>00245         }                                                                                                                               
<a name="l00246"></a><a class="code" href="class_h_a_c_d_1_1_h_a_c_d.html#a38511d80e4d64632fa080dfed54f59d7">00246</a>         <a class="code" href="class_h_a_c_d_1_1_h_a_c_d.html#a38511d80e4d64632fa080dfed54f59d7">HACD::~HACD</a>(<span class="keywordtype">void</span>)
<a name="l00247"></a>00247         {
<a name="l00248"></a>00248                 <span class="keyword">delete</span> [] m_normals;
<a name="l00249"></a>00249         <span class="keyword">delete</span> [] m_convexHulls;
<a name="l00250"></a>00250         }
<a name="l00251"></a>00251     
<a name="l00252"></a>00252     <span class="keywordtype">void</span> HACD::ComputeEdgeCost(<span class="keywordtype">size_t</span> e)
<a name="l00253"></a>00253     {
<a name="l00254"></a>00254         <span class="keywordtype">long</span> v1 = m_graph.m_edges[e].m_v1;
<a name="l00255"></a>00255         <span class="keywordtype">long</span> v2 = m_graph.m_edges[e].m_v2;
<a name="l00256"></a>00256         <span class="keywordflow">if</span> (m_graph.m_vertices[v2].m_distPoints.size()&gt;m_graph.m_vertices[v1].m_distPoints.size())
<a name="l00257"></a>00257         {
<a name="l00258"></a>00258             m_graph.m_edges[e].m_v1 = v2;
<a name="l00259"></a>00259             m_graph.m_edges[e].m_v2 = v1;
<a name="l00260"></a>00260             std::swap&lt;long&gt;(v1, v2);
<a name="l00261"></a>00261         }
<a name="l00262"></a>00262 
<a name="l00263"></a>00263         <span class="comment">// delete old convex-hull</span>
<a name="l00264"></a>00264         <span class="keyword">delete</span> m_graph.m_edges[e].m_convexHull;
<a name="l00265"></a>00265         <span class="comment">// create the edge&#39;s convex-hull</span>
<a name="l00266"></a>00266         ICHull  * ch = <span class="keyword">new</span> ICHull;
<a name="l00267"></a>00267         m_graph.m_edges[e].m_convexHull = ch;
<a name="l00268"></a>00268         (*ch) = (*m_graph.m_vertices[v1].m_convexHull);
<a name="l00269"></a>00269         
<a name="l00270"></a>00270                 <span class="comment">// update distPoints</span>
<a name="l00271"></a>00271                 m_graph.m_edges[e].m_distPoints = m_graph.m_vertices[v1].m_distPoints;
<a name="l00272"></a>00272                 std::map&lt;long, DPoint&gt;::iterator itDP(m_graph.m_vertices[v2].m_distPoints.begin());
<a name="l00273"></a>00273                 std::map&lt;long, DPoint&gt;::iterator itDPEnd(m_graph.m_vertices[v2].m_distPoints.end());
<a name="l00274"></a>00274                 std::map&lt;long, DPoint&gt;::iterator itDP1;
<a name="l00275"></a>00275                 <span class="keywordflow">for</span>(; itDP != itDPEnd; ++itDP) 
<a name="l00276"></a>00276                 {
<a name="l00277"></a>00277                         itDP1 = m_graph.m_edges[e].m_distPoints.find(itDP-&gt;first);
<a name="l00278"></a>00278                         <span class="keywordflow">if</span> (itDP1 == m_graph.m_edges[e].m_distPoints.end())
<a name="l00279"></a>00279                         {
<a name="l00280"></a>00280                                 m_graph.m_edges[e].m_distPoints[itDP-&gt;first];
<a name="l00281"></a>00281                 ch-&gt;AddPoint(m_points[itDP-&gt;first], itDP-&gt;first);
<a name="l00282"></a>00282                         }
<a name="l00283"></a>00283                 }
<a name="l00284"></a>00284                 ch-&gt;SetDistPoints(&amp;m_graph.m_edges[e].m_distPoints);
<a name="l00285"></a>00285 
<a name="l00286"></a>00286         <span class="comment">// create the convex-hull</span>
<a name="l00287"></a>00287         ch-&gt;Process();
<a name="l00288"></a>00288        
<a name="l00289"></a>00289                 std::vector&lt;long&gt; triangles = m_graph.m_vertices[v1].m_ancestors;
<a name="l00290"></a>00290                 triangles.insert(triangles.end(), 
<a name="l00291"></a>00291                                                  m_graph.m_vertices[v1].m_ancestors.begin(),
<a name="l00292"></a>00292                                                  m_graph.m_vertices[v1].m_ancestors.end());
<a name="l00293"></a>00293                 triangles.push_back(v1);
<a name="l00294"></a>00294                 triangles.push_back(v2);
<a name="l00295"></a>00295 
<a name="l00296"></a>00296         <span class="keywordtype">double</span> surf      = m_graph.m_vertices[v1].m_surf + m_graph.m_vertices[v2].m_surf;
<a name="l00297"></a>00297         <span class="keywordtype">double</span> perimeter = 0.0;
<a name="l00298"></a>00298                 <span class="keywordflow">if</span> (m_alpha &gt; 0.0 )
<a name="l00299"></a>00299                 {
<a name="l00300"></a>00300                         perimeter = ComputePerimeter(triangles);
<a name="l00301"></a>00301                 }
<a name="l00302"></a>00302         <span class="keywordtype">double</span> ratio     = perimeter * perimeter / (4.0 * <a class="code" href="namespace_h_a_c_d.html#a36c916703393e603dd7327e9b548271b">sc_pi</a> * surf);
<a name="l00303"></a>00303         <span class="keywordtype">double</span> concavity = Concavity(*ch, m_graph.m_edges[e].m_distPoints);
<a name="l00304"></a>00304         
<a name="l00305"></a>00305         m_graph.m_edges[e].m_surf      = surf;                          <span class="comment">// clusterSurf  </span>
<a name="l00306"></a>00306         m_graph.m_edges[e].m_perimeter = perimeter;                     <span class="comment">// recompute the perimeter</span>
<a name="l00307"></a>00307         m_graph.m_edges[e].m_concavity = concavity;                     <span class="comment">// concavity</span>
<a name="l00308"></a>00308         m_graph.m_edges[e].m_error     = concavity +  m_alpha * ratio;  <span class="comment">// priority </span>
<a name="l00309"></a>00309     }
<a name="l00310"></a>00310     <span class="keywordtype">bool</span> HACD::InitializePQ()
<a name="l00311"></a>00311     {
<a name="l00312"></a>00312         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> e=0; e &lt; m_graph.m_nE; ++e) 
<a name="l00313"></a>00313         {
<a name="l00314"></a>00314             ComputeEdgeCost(e);
<a name="l00315"></a>00315             m_pqueue.push(GraphEdgePQ(e, m_graph.m_edges[e].m_error));
<a name="l00316"></a>00316         }
<a name="l00317"></a>00317                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00318"></a>00318     }
<a name="l00319"></a>00319 
<a name="l00320"></a><a class="code" href="class_h_a_c_d_1_1_h_a_c_d.html#abff5012122b20ae4eca9cffe4adaa4b9">00320</a>     <span class="keywordtype">bool</span> <a class="code" href="class_h_a_c_d_1_1_h_a_c_d.html#abff5012122b20ae4eca9cffe4adaa4b9">HACD::Compute</a>(<span class="keywordtype">double</span> concavity, <span class="keywordtype">bool</span> connectCCs, <span class="keywordtype">bool</span> fullCH)
<a name="l00321"></a>00321     {
<a name="l00322"></a>00322                 <span class="keywordflow">if</span> ( !m_points || !m_triangles || !m_nPoints || !m_nTriangles)
<a name="l00323"></a>00323                 {
<a name="l00324"></a>00324                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00325"></a>00325                 }
<a name="l00326"></a>00326                 <span class="keywordtype">size_t</span> nV = m_nTriangles;
<a name="l00327"></a>00327                 m_concavity = concavity; 
<a name="l00328"></a>00328                 <span class="keywordflow">if</span> (m_callBack) (*m_callBack)(<span class="stringliteral">&quot;Normalizing Data \n&quot;</span>, 0.0, 0.0, nV);
<a name="l00329"></a>00329                 NormalizeData();
<a name="l00330"></a>00330                 <span class="keywordflow">if</span> (m_callBack) (*m_callBack)(<span class="stringliteral">&quot;+ Creating Graph ...\n&quot;</span>, 0.0, 0.0, nV);
<a name="l00331"></a>00331                 CreateGraph(connectCCs);
<a name="l00332"></a>00332         <span class="comment">// Compute the surfaces and perimeters of all the faces</span>
<a name="l00333"></a>00333                 <span class="keywordflow">if</span> (m_callBack) (*m_callBack)(<span class="stringliteral">&quot;+ Initializing Graph ...\n&quot;</span>, 0.0, 0.0, nV);
<a name="l00334"></a>00334                 InitializeGraph();
<a name="l00335"></a>00335                 <span class="keywordflow">if</span> (m_callBack) (*m_callBack)(<span class="stringliteral">&quot;+ Initializing PQ ...\n&quot;</span>, 0.0, 0.0, nV);
<a name="l00336"></a>00336         InitializePQ();
<a name="l00337"></a>00337         
<a name="l00338"></a>00338         <span class="comment">//--- we simplify the stuff</span>
<a name="l00339"></a>00339                 
<a name="l00340"></a>00340         <span class="keywordtype">long</span> v1 = -1;
<a name="l00341"></a>00341         <span class="keywordtype">long</span> v2 = -1;
<a name="l00342"></a>00342         
<a name="l00343"></a>00343         <span class="keywordtype">double</span> progressOld = -1.0;
<a name="l00344"></a>00344         <span class="keywordtype">double</span> progress = 0.0;
<a name="l00345"></a>00345                 <span class="keywordflow">if</span> (m_callBack) (*m_callBack)(<span class="stringliteral">&quot;+ Simplification ...\n&quot;</span>, 0.0, 0.0, nV);
<a name="l00346"></a>00346 
<a name="l00347"></a>00347         <span class="keywordtype">double</span> globalConcavity  = 0.0;     
<a name="l00348"></a>00348                 <span class="keywordtype">char</span> msg[1024];
<a name="l00349"></a>00349         <span class="keywordflow">while</span> ( (globalConcavity &lt; m_concavity) &amp;&amp; 
<a name="l00350"></a>00350                                 (m_graph.<a class="code" href="class_h_a_c_d_1_1_graph.html#a170da164967427bcbe8948740eb39bbe">GetNVertices</a>() &gt; m_nClusters) &amp;&amp; 
<a name="l00351"></a>00351                                 (m_graph.<a class="code" href="class_h_a_c_d_1_1_graph.html#aff12e58ade1dbbad5d511c29309fab68">GetNEdges</a>()&gt; 1)) 
<a name="l00352"></a>00352                 {
<a name="l00353"></a>00353                         <span class="keywordflow">if</span> (m_callBack) (*m_callBack)(<span class="stringliteral">&quot;&quot;</span>, 0.0, 0.0, nV);
<a name="l00354"></a>00354 
<a name="l00355"></a>00355             progress = 100.0-m_graph.<a class="code" href="class_h_a_c_d_1_1_graph.html#a170da164967427bcbe8948740eb39bbe">GetNVertices</a>() * 100.0 / nV;
<a name="l00356"></a>00356             <span class="keywordflow">if</span> (fabs(progress-progressOld) &gt; 0.1 &amp;&amp; m_callBack)
<a name="l00357"></a>00357             {
<a name="l00358"></a>00358                                 sprintf(msg, <span class="stringliteral">&quot;%3.2f V = %i \t C = %f\r&quot;</span>, progress, m_graph.<a class="code" href="class_h_a_c_d_1_1_graph.html#a170da164967427bcbe8948740eb39bbe">GetNVertices</a>(), globalConcavity);
<a name="l00359"></a>00359                                 (*m_callBack)(msg, progress, globalConcavity,  m_graph.<a class="code" href="class_h_a_c_d_1_1_graph.html#a170da164967427bcbe8948740eb39bbe">GetNVertices</a>());
<a name="l00360"></a>00360                 progressOld = progress;
<a name="l00361"></a>00361             }
<a name="l00362"></a>00362 
<a name="l00363"></a>00363                         <a class="code" href="class_h_a_c_d_1_1_graph_edge_p_q.html">GraphEdgePQ</a> currentEdge(0,0.0);
<a name="l00364"></a>00364                         <span class="keywordtype">bool</span> done = <span class="keyword">false</span>;
<a name="l00365"></a>00365                         <span class="keywordflow">do</span>
<a name="l00366"></a>00366                         {
<a name="l00367"></a>00367                                 done = <span class="keyword">false</span>;
<a name="l00368"></a>00368                                 <span class="keywordflow">if</span> (m_pqueue.size() == 0)
<a name="l00369"></a>00369                                 {
<a name="l00370"></a>00370                                         done = <span class="keyword">true</span>;
<a name="l00371"></a>00371                                         <span class="keywordflow">break</span>;
<a name="l00372"></a>00372                                 }
<a name="l00373"></a>00373                                 <span class="keywordflow">else</span>
<a name="l00374"></a>00374                                 {
<a name="l00375"></a>00375                                         currentEdge = m_pqueue.top();
<a name="l00376"></a>00376                                         m_pqueue.pop();
<a name="l00377"></a>00377                                 }
<a name="l00378"></a>00378                         }
<a name="l00379"></a>00379                         <span class="keywordflow">while</span> (  m_graph.m_edges[currentEdge.m_name].m_deleted || 
<a name="l00380"></a>00380                                          m_graph.m_edges[currentEdge.m_name].m_error != currentEdge.m_priority);
<a name="l00381"></a>00381 
<a name="l00382"></a>00382                         
<a name="l00383"></a>00383 
<a name="l00384"></a>00384                         <span class="keywordflow">if</span> (m_graph.m_edges[currentEdge.m_name].m_concavity &lt; m_concavity &amp;&amp; !done)
<a name="l00385"></a>00385                         {
<a name="l00386"></a>00386                 globalConcavity = std::max&lt;double&gt;(globalConcavity ,m_graph.m_edges[currentEdge.m_name].m_concavity);
<a name="l00387"></a>00387                                 v1 = m_graph.m_edges[currentEdge.m_name].m_v1;
<a name="l00388"></a>00388                                 v2 = m_graph.m_edges[currentEdge.m_name].m_v2;  
<a name="l00389"></a>00389                                 <span class="comment">// update vertex info</span>
<a name="l00390"></a>00390                                 m_graph.m_vertices[v1].m_error     = m_graph.m_edges[currentEdge.m_name].m_error;
<a name="l00391"></a>00391                                 m_graph.m_vertices[v1].m_surf      = m_graph.m_edges[currentEdge.m_name].m_surf;
<a name="l00392"></a>00392                                 m_graph.m_vertices[v1].m_concavity = m_graph.m_edges[currentEdge.m_name].m_concavity;
<a name="l00393"></a>00393                                 m_graph.m_vertices[v1].m_perimeter = m_graph.m_edges[currentEdge.m_name].m_perimeter;
<a name="l00394"></a>00394                 m_graph.m_vertices[v1].m_distPoints   = m_graph.m_edges[currentEdge.m_name].m_distPoints;
<a name="l00395"></a>00395                 (*m_graph.m_vertices[v1].m_convexHull) = (*m_graph.m_edges[currentEdge.m_name].m_convexHull);
<a name="l00396"></a>00396                                 (m_graph.m_vertices[v1].m_convexHull)-&gt;SetDistPoints(&amp;(m_graph.m_vertices[v1].m_distPoints));                           
<a name="l00397"></a>00397                     
<a name="l00398"></a>00398                                 <span class="comment">// We apply the optimal ecol</span>
<a name="l00399"></a>00399                                 m_graph.<a class="code" href="class_h_a_c_d_1_1_graph.html#acecb11031d9404fcfe62d6c2d3323428">EdgeCollapse</a>(v1, v2);
<a name="l00400"></a>00400                                 <span class="comment">// recompute the adjacent edges costs</span>
<a name="l00401"></a>00401                                 std::set&lt;long&gt;::const_iterator itE(m_graph.m_vertices[v1].m_edges.begin()), 
<a name="l00402"></a>00402                                                                                            itEEnd(m_graph.m_vertices[v1].m_edges.end());
<a name="l00403"></a>00403                                 <span class="keywordflow">for</span>(; itE != itEEnd; ++itE)
<a name="l00404"></a>00404                                 {
<a name="l00405"></a>00405                                         <span class="keywordtype">size_t</span> e = *itE;
<a name="l00406"></a>00406                                         ComputeEdgeCost(e);
<a name="l00407"></a>00407                                         m_pqueue.push(<a class="code" href="class_h_a_c_d_1_1_graph_edge_p_q.html">GraphEdgePQ</a>(e, m_graph.m_edges[e].m_error));
<a name="l00408"></a>00408                                 }
<a name="l00409"></a>00409                         }
<a name="l00410"></a>00410             <span class="keywordflow">else</span>
<a name="l00411"></a>00411             {
<a name="l00412"></a>00412                 <span class="keywordflow">break</span>;
<a name="l00413"></a>00413             }
<a name="l00414"></a>00414         }
<a name="l00415"></a>00415         m_nClusters = m_graph.<a class="code" href="class_h_a_c_d_1_1_graph.html#a170da164967427bcbe8948740eb39bbe">GetNVertices</a>();
<a name="l00416"></a>00416         <span class="keyword">delete</span> [] m_convexHulls;
<a name="l00417"></a>00417         m_convexHulls = <span class="keyword">new</span> <a class="code" href="class_h_a_c_d_1_1_i_c_hull.html" title="Incremental Convex Hull algorithm (cf. http://maven.smith.edu/~orourke/books/ftp.html )...">ICHull</a>[m_nClusters];
<a name="l00418"></a>00418         m_cVertices.clear();
<a name="l00419"></a>00419         m_cVertices.reserve(m_nClusters);
<a name="l00420"></a>00420         <span class="keywordtype">size_t</span> p=0;
<a name="l00421"></a>00421         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> v = 0; v != m_graph.m_vertices.size(); ++v) 
<a name="l00422"></a>00422                 {
<a name="l00423"></a>00423                         <span class="keywordflow">if</span> (!m_graph.m_vertices[v].m_deleted)
<a name="l00424"></a>00424                         {
<a name="l00425"></a>00425                 m_cVertices.push_back(v);                       
<a name="l00426"></a>00426                 <span class="comment">// compute the convex-hull</span>
<a name="l00427"></a>00427                 <span class="keyword">const</span> std::map&lt;long, DPoint&gt; &amp; pointsCH =  m_graph.m_vertices[v].m_distPoints;
<a name="l00428"></a>00428                 std::map&lt;long, DPoint&gt;::const_iterator itCH(pointsCH.begin());
<a name="l00429"></a>00429                 std::map&lt;long, DPoint&gt;::const_iterator itCHEnd(pointsCH.end());
<a name="l00430"></a>00430                 <span class="keywordflow">for</span>(; itCH != itCHEnd; ++itCH) 
<a name="l00431"></a>00431                 {
<a name="l00432"></a>00432                                         m_convexHulls[p].<a class="code" href="class_h_a_c_d_1_1_i_c_hull.html#a1d8ab100cfa4006632617d02b337ef1b" title="Add one point to the convex-hull.">AddPoint</a>(m_points[itCH-&gt;first], itCH-&gt;first);
<a name="l00433"></a>00433                 }
<a name="l00434"></a>00434                 <span class="keywordflow">if</span> (fullCH)
<a name="l00435"></a>00435                 {
<a name="l00436"></a>00436                     m_convexHulls[p].<a class="code" href="class_h_a_c_d_1_1_i_c_hull.html#a72c3431006799009793bbc3765e35917">Process</a>();
<a name="l00437"></a>00437                 }
<a name="l00438"></a>00438                 <span class="keywordflow">else</span>
<a name="l00439"></a>00439                 {
<a name="l00440"></a>00440                     m_convexHulls[p].<a class="code" href="class_h_a_c_d_1_1_i_c_hull.html#a72c3431006799009793bbc3765e35917">Process</a>(m_nVerticesPerCH);
<a name="l00441"></a>00441                 }
<a name="l00442"></a>00442                 p++;
<a name="l00443"></a>00443                         }
<a name="l00444"></a>00444                 }
<a name="l00445"></a>00445 
<a name="l00446"></a>00446         <span class="keywordflow">if</span> (m_callBack)
<a name="l00447"></a>00447         {
<a name="l00448"></a>00448                         sprintf(msg, <span class="stringliteral">&quot;# clusters =  %i \t C = %f\n&quot;</span>, m_nClusters, globalConcavity);
<a name="l00449"></a>00449                         (*m_callBack)(msg, progress, globalConcavity,  m_graph.<a class="code" href="class_h_a_c_d_1_1_graph.html#a170da164967427bcbe8948740eb39bbe">GetNVertices</a>());
<a name="l00450"></a>00450         }
<a name="l00451"></a>00451         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00452"></a>00452     }
<a name="l00453"></a>00453     <span class="keywordtype">void</span> HACD::ComputePartition(<span class="keywordtype">long</span> * partition)<span class="keyword"> const</span>
<a name="l00454"></a>00454 <span class="keyword">    </span>{
<a name="l00455"></a>00455         <span class="comment">// we fill the partition       </span>
<a name="l00456"></a>00456         <span class="keywordflow">if</span> (m_callBack) (*m_callBack)(<span class="stringliteral">&quot;+ Filling partition...\n&quot;</span>, 0.0, 0.0, m_graph.<a class="code" href="class_h_a_c_d_1_1_graph.html#a170da164967427bcbe8948740eb39bbe">GetNVertices</a>());
<a name="l00457"></a>00457                 std::vector&lt;long&gt;::const_iterator it;
<a name="l00458"></a>00458         <span class="keywordtype">size_t</span> v;
<a name="l00459"></a>00459         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> p = 0; p != m_cVertices.size(); ++p) 
<a name="l00460"></a>00460                 {
<a name="l00461"></a>00461             v = m_cVertices[p];
<a name="l00462"></a>00462             partition[v] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">long</span><span class="keyword">&gt;</span>(p);            
<a name="l00463"></a>00463             <span class="keywordflow">for</span> (it =  m_graph.m_vertices[v].m_ancestors.begin();
<a name="l00464"></a>00464                  it != m_graph.m_vertices[v].m_ancestors.end(); ++it) 
<a name="l00465"></a>00465             {
<a name="l00466"></a>00466                 partition[*it] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">long</span><span class="keyword">&gt;</span>(p);
<a name="l00467"></a>00467             }
<a name="l00468"></a>00468         }
<a name="l00469"></a>00469     }
<a name="l00470"></a><a class="code" href="class_h_a_c_d_1_1_h_a_c_d.html#a06fb62f6e5f20c95d75f32424affcfac">00470</a>     <span class="keywordtype">size_t</span> <a class="code" href="class_h_a_c_d_1_1_h_a_c_d.html#a06fb62f6e5f20c95d75f32424affcfac">HACD::GetNPointsCH</a>(<span class="keywordtype">size_t</span> numCH)<span class="keyword"> const</span>
<a name="l00471"></a>00471 <span class="keyword">    </span>{
<a name="l00472"></a>00472         <span class="keywordflow">if</span> (numCH &gt;= m_nClusters)
<a name="l00473"></a>00473         {
<a name="l00474"></a>00474             <span class="keywordflow">return</span> 0;
<a name="l00475"></a>00475         }
<a name="l00476"></a>00476         <span class="keywordflow">return</span> m_convexHulls[numCH].<a class="code" href="class_h_a_c_d_1_1_i_c_hull.html#a8315592856dfefeb5f16cdaff8e0462e" title="Returns the computed mesh.">GetMesh</a>().<a class="code" href="class_h_a_c_d_1_1_t_m_mesh.html#a45fee50bdd466e85948601e686a9f2d0" title="Returns the number of vertices&gt;">GetNVertices</a>();
<a name="l00477"></a>00477     }
<a name="l00478"></a><a class="code" href="class_h_a_c_d_1_1_h_a_c_d.html#a2d84cf35a49d0b83269e2d84f3cffbbc">00478</a>     <span class="keywordtype">size_t</span> <a class="code" href="class_h_a_c_d_1_1_h_a_c_d.html#a2d84cf35a49d0b83269e2d84f3cffbbc">HACD::GetNTrianglesCH</a>(<span class="keywordtype">size_t</span> numCH)<span class="keyword"> const</span>
<a name="l00479"></a>00479 <span class="keyword">    </span>{
<a name="l00480"></a>00480         <span class="keywordflow">if</span> (numCH &gt;= m_nClusters)
<a name="l00481"></a>00481         {
<a name="l00482"></a>00482             <span class="keywordflow">return</span> 0;
<a name="l00483"></a>00483         }
<a name="l00484"></a>00484         <span class="keywordflow">return</span> m_convexHulls[numCH].<a class="code" href="class_h_a_c_d_1_1_i_c_hull.html#a8315592856dfefeb5f16cdaff8e0462e" title="Returns the computed mesh.">GetMesh</a>().<a class="code" href="class_h_a_c_d_1_1_t_m_mesh.html#af162d336900be13f51fc1e0e865d8023" title="Returns the number of triangles.">GetNTriangles</a>();
<a name="l00485"></a>00485     }
<a name="l00486"></a><a class="code" href="class_h_a_c_d_1_1_h_a_c_d.html#a7f58a9f1a358684b6ea35b347c20bed6">00486</a>     <span class="keywordtype">bool</span> <a class="code" href="class_h_a_c_d_1_1_h_a_c_d.html#a7f58a9f1a358684b6ea35b347c20bed6">HACD::GetCH</a>(<span class="keywordtype">size_t</span> numCH, <a class="code" href="class_h_a_c_d_1_1_vec3.html">Vec3&lt;double&gt;</a> * <span class="keyword">const</span> points, <a class="code" href="class_h_a_c_d_1_1_vec3.html">Vec3&lt;long&gt;</a> * <span class="keyword">const</span> triangles)
<a name="l00487"></a>00487     {
<a name="l00488"></a>00488         <span class="keywordflow">if</span> (numCH &gt;= m_nClusters)
<a name="l00489"></a>00489         {
<a name="l00490"></a>00490             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00491"></a>00491         }
<a name="l00492"></a>00492         m_convexHulls[numCH].<a class="code" href="class_h_a_c_d_1_1_i_c_hull.html#a8315592856dfefeb5f16cdaff8e0462e" title="Returns the computed mesh.">GetMesh</a>().<a class="code" href="class_h_a_c_d_1_1_t_m_mesh.html#ad24d52dd81dcccd306ced5381df0edaf">GetIFS</a>(points, triangles);
<a name="l00493"></a>00493         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00494"></a>00494     }
<a name="l00495"></a>00495 
<a name="l00496"></a><a class="code" href="class_h_a_c_d_1_1_h_a_c_d.html#af5421ff7c9c1d2d8f51e4014dbe82d4b">00496</a>     <span class="keywordtype">void</span> <a class="code" href="class_h_a_c_d_1_1_h_a_c_d.html#af5421ff7c9c1d2d8f51e4014dbe82d4b">HACD::Save</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * fileName, <span class="keywordtype">bool</span> uniColor)<span class="keyword"> const</span>
<a name="l00497"></a>00497 <span class="keyword">    </span>{
<a name="l00498"></a>00498         std::ofstream fout(fileName);
<a name="l00499"></a>00499                 <span class="keywordflow">if</span> (m_callBack)
<a name="l00500"></a>00500                 {
<a name="l00501"></a>00501                         <span class="keywordtype">char</span> msg[1024];
<a name="l00502"></a>00502                         sprintf(msg, <span class="stringliteral">&quot;Saving %s\n&quot;</span>, fileName);
<a name="l00503"></a>00503                         (*m_callBack)(msg, 0.0, 0.0, m_graph.<a class="code" href="class_h_a_c_d_1_1_graph.html#a170da164967427bcbe8948740eb39bbe">GetNVertices</a>());
<a name="l00504"></a>00504                 }
<a name="l00505"></a>00505                 <a class="code" href="class_h_a_c_d_1_1_material.html">Material</a> mat;
<a name="l00506"></a>00506         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> p = 0; p != m_cVertices.size(); ++p) 
<a name="l00507"></a>00507                 {
<a name="l00508"></a>00508             <span class="keywordflow">if</span> (!uniColor)
<a name="l00509"></a>00509             {
<a name="l00510"></a>00510                 mat.m_diffuseColor.<a class="code" href="class_h_a_c_d_1_1_vec3.html#a237c6c8e8e17ceea9baad0753899ad61">X</a>() = mat.m_diffuseColor.<a class="code" href="class_h_a_c_d_1_1_vec3.html#a8e251b079fa8d1b3206c4c8bba5f1528">Y</a>() = mat.m_diffuseColor.<a class="code" href="class_h_a_c_d_1_1_vec3.html#abb17e95e4f8b954d1a548d481b60108e">Z</a>() = 0.0;
<a name="l00511"></a>00511                 <span class="keywordflow">while</span> (mat.m_diffuseColor.<a class="code" href="class_h_a_c_d_1_1_vec3.html#a237c6c8e8e17ceea9baad0753899ad61">X</a>() == mat.m_diffuseColor.<a class="code" href="class_h_a_c_d_1_1_vec3.html#a8e251b079fa8d1b3206c4c8bba5f1528">Y</a>() ||
<a name="l00512"></a>00512                        mat.m_diffuseColor.<a class="code" href="class_h_a_c_d_1_1_vec3.html#abb17e95e4f8b954d1a548d481b60108e">Z</a>() == mat.m_diffuseColor.<a class="code" href="class_h_a_c_d_1_1_vec3.html#a8e251b079fa8d1b3206c4c8bba5f1528">Y</a>() ||
<a name="l00513"></a>00513                        mat.m_diffuseColor.<a class="code" href="class_h_a_c_d_1_1_vec3.html#abb17e95e4f8b954d1a548d481b60108e">Z</a>() == mat.m_diffuseColor.<a class="code" href="class_h_a_c_d_1_1_vec3.html#a237c6c8e8e17ceea9baad0753899ad61">X</a>()  )
<a name="l00514"></a>00514                 {
<a name="l00515"></a>00515                     mat.m_diffuseColor.<a class="code" href="class_h_a_c_d_1_1_vec3.html#a237c6c8e8e17ceea9baad0753899ad61">X</a>() = (rand()%100) / 100.0;
<a name="l00516"></a>00516                     mat.m_diffuseColor.<a class="code" href="class_h_a_c_d_1_1_vec3.html#a8e251b079fa8d1b3206c4c8bba5f1528">Y</a>() = (rand()%100) / 100.0;
<a name="l00517"></a>00517                     mat.m_diffuseColor.<a class="code" href="class_h_a_c_d_1_1_vec3.html#abb17e95e4f8b954d1a548d481b60108e">Z</a>() = (rand()%100) / 100.0;
<a name="l00518"></a>00518                 }
<a name="l00519"></a>00519             }
<a name="l00520"></a>00520             m_convexHulls[p].<a class="code" href="class_h_a_c_d_1_1_i_c_hull.html#a8315592856dfefeb5f16cdaff8e0462e" title="Returns the computed mesh.">GetMesh</a>().<a class="code" href="class_h_a_c_d_1_1_t_m_mesh.html#a8c0a261c9d3ec3a96039efbcdcf0eac0" title="Save mesh to VRML 2.0 format.">SaveVRML2</a>(fout, mat);
<a name="l00521"></a>00521                 }
<a name="l00522"></a>00522     }
<a name="l00523"></a>00523 }
</pre></div></div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Mon May 2 2011 15:54:21 for HACD by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
